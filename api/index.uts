/**
 * å°ååŒå­¦AI
 * API è¯·æ±‚å·¥å…·ç±»
 * å°è£…uni.requestï¼Œç»Ÿä¸€å¤„ç†è¯·æ±‚å’Œå“åº”
 */

// å¯¼å…¥é…ç½®
import { API_BASE_URL, TENANT_ID, TIMEOUT, UPLOAD_CONFIG } from './config';

// å“åº”æ•°æ®æ¥å£
export interface ApiResponse<T> {
    code: number;
    msg: string;
    data: T;
}

// è¯·æ±‚é…ç½®æ¥å£
export interface RequestOptions {
    url: string;
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
    data?: any;
    params?: any; // GETè¯·æ±‚çš„æŸ¥è¯¢å‚æ•°
    header?: any;
    timeout?: number;
    isAuth?: boolean; // æ˜¯å¦éœ€è¦æˆæƒ
    retryCount?: number; // é‡è¯•æ¬¡æ•°
}

// å…¨å±€å˜é‡ï¼šé˜²æ­¢é‡å¤è·³è½¬ç™»å½•é¡µ
let isRedirectingToLogin = false;
let redirectTimer: number | null = null;

// Tokenåˆ·æ–°ç›¸å…³å…¨å±€å˜é‡
let isRefreshingToken = false;
let refreshTokenPromise: Promise<string> | null = null;

// Seal-Token å…‘æ¢ç›¸å…³å…¨å±€å˜é‡ï¼ˆé˜²æ­¢å¹¶å‘é‡å¤å…‘æ¢ï¼‰
let isGeneratingSealToken = false;
let generateSealTokenPromise: Promise<string> | null = null;

/**
 * ğŸ†• ç¡®ä¿ Seal-Token å­˜åœ¨ï¼ˆåœ¨å‘é€sealä¸šåŠ¡è¯·æ±‚å‰è°ƒç”¨ï¼‰
 * å¦‚æœæœ¬åœ°æ²¡æœ‰sealTokenï¼Œè‡ªåŠ¨è°ƒç”¨exchange-tokenæ¥å£è·å–
 */
async function ensureSealTokenInternal(): Promise<string> {
    // æ£€æŸ¥æœ¬åœ°æ˜¯å¦å·²æœ‰ sealToken
    const existingToken = uni.getStorageSync('sealToken');
    if (existingToken) {
        return existingToken;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ member tokenï¼ˆå‰ææ¡ä»¶ï¼‰
    const memberToken = uni.getStorageSync('token');
    if (!memberToken) {
        throw new Error('è¯·å…ˆç™»å½•');
    }
    
    // å¦‚æœæ­£åœ¨è·å–ä¸­ï¼Œç­‰å¾…ç°æœ‰çš„ Promise
    if (isGeneratingSealToken && generateSealTokenPromise) {
        console.log('[API] â³ Seal-Token æ­£åœ¨è·å–ä¸­ï¼Œç­‰å¾…...');
        return generateSealTokenPromise;
    }
    
    console.log('[API] ğŸ”„ Seal-Token ä¸å­˜åœ¨ï¼Œè‡ªåŠ¨è·å–...');
    isGeneratingSealToken = true;
    
    generateSealTokenPromise = new Promise<string>((resolve, reject) => {
        uni.request({
            url: `${API_BASE_URL}/api/v1/seal/auth/exchange-token`,
            method: 'POST',
            data: { expireMinutes: 43200 }, // 30å¤©
            header: {
                'Content-Type': 'application/json',
                'tenant-id': TENANT_ID,
                'Authorization': `Bearer ${memberToken}`
            },
            success: (res: any) => {
                if (res.statusCode === 200) {
                    const data = res.data;
                    if (data.code === 0 && data.data?.token) {
                        const newToken = data.data.token;
                        uni.setStorageSync('sealToken', newToken);
                        console.log('[API] âœ… Seal-Token è‡ªåŠ¨è·å–æˆåŠŸ');
                        resolve(newToken);
                    } else {
                        console.error('[API] âŒ Seal-Token è·å–å¤±è´¥:', data.msg);
                        reject(new Error(data.msg || 'Seal-Tokenè·å–å¤±è´¥'));
                    }
                } else {
                    reject(new Error(`HTTP ${res.statusCode}`));
                }
            },
            fail: (err: any) => {
                console.error('[API] âŒ Seal-Token ç½‘ç»œé”™è¯¯:', err);
                reject(err);
            }
        });
    });
    
    try {
        const token = await generateSealTokenPromise;
        return token;
    } finally {
        isGeneratingSealToken = false;
        generateSealTokenPromise = null;
    }
}

// ä¸Šä¼ è¿›åº¦å›è°ƒæ¥å£
export interface UploadProgressCallback {
    (percent: number): void;
}

/**
 * åˆ·æ–°token
 */
async function refreshToken(): Promise<string> {
    // å¦‚æœå·²ç»åœ¨åˆ·æ–°ä¸­ï¼Œè¿”å›ç°æœ‰çš„Promise
    if (isRefreshingToken && refreshTokenPromise) {
        console.log('========== Tokenåˆ·æ–°ï¼šå¹¶å‘è¯·æ±‚ï¼Œç­‰å¾…ç°æœ‰åˆ·æ–°å®Œæˆ ==========');
        return refreshTokenPromise;
    }
    
    console.log('========== å¼€å§‹åˆ·æ–°Tokenæµç¨‹ ==========');
    isRefreshingToken = true;
    refreshTokenPromise = new Promise<string>(async (resolve, reject) => {
        try {
            const refreshToken = uni.getStorageSync('refreshToken');
            if (!refreshToken) {
                console.error('âŒ åˆ·æ–°å¤±è´¥ï¼šæ²¡æœ‰refreshToken');
                reject(new Error('ç™»å½•ä¿¡æ¯å·²å¤±æ•ˆ'));
                return;
            }
            
            console.log('âœ… æ‰¾åˆ°refreshToken:', refreshToken.substring(0, 30) + '...');

            
            const response = await new Promise<any>((resolveRefresh, rejectRefresh) => {
                uni.request({
                    url: buildFullUrl('/api/v1/member/auth/refresh-token'),
                    method: 'POST',
                    header: {
                        'Content-Type': 'application/json',
                        'tenant-id': TENANT_ID
                    },
                    data: {
                        refreshToken: refreshToken
                    },
                    success: (res: any) => {
                        console.log('ğŸ“¥ åˆ·æ–°Tokenå“åº”çŠ¶æ€:', res.statusCode);
                        if (res.statusCode === 200 && res.data) {
                            const data = typeof res.data === 'string' ? JSON.parse(res.data) : res.data;
                            console.log('ğŸ“¥ åˆ·æ–°Tokenå“åº”æ•°æ®:', JSON.stringify(data));
                            
                            if (data && (data.code === 0 || data.code === 200)) {
                                console.log('âœ… åˆ·æ–°TokenæˆåŠŸï¼Œè¿”å›æ•°æ®:', data.data);
                                resolveRefresh(data.data);
                            } else {
                                console.error('âŒ åˆ·æ–°Tokenä¸šåŠ¡é”™è¯¯ - Code:', data?.code, 'Message:', data?.msg);
                                rejectRefresh(new Error(data?.msg || 'åˆ·æ–°tokenå¤±è´¥'));
                            }
                        } else {
                            console.error('âŒ åˆ·æ–°Token HTTPé”™è¯¯ - Status:', res.statusCode);
                            rejectRefresh(new Error(`HTTP ${res.statusCode}: åˆ·æ–°tokenå¤±è´¥`));
                        }
                    },
                    fail: (err: any) => {
                        console.error('âŒ åˆ·æ–°Tokenç½‘ç»œé”™è¯¯:', err);
                        rejectRefresh(err);
                    }
                });
            });
            
            // ä¿å­˜æ–°token
            const newToken = response.accessToken || response.token;
            const newRefreshToken = response.refreshToken;
            
            console.log('æ”¶åˆ°æ–°Token:', newToken ? (newToken.substring(0, 30) + '...') : 'æ— ');
            console.log('æ”¶åˆ°æ–°RefreshToken:', newRefreshToken ? (newRefreshToken.substring(0, 30) + '...') : 'æ— ');
            
            if (newToken) {
                uni.setStorageSync('token', newToken);
                console.log('âœ… æ–°Tokenå·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
                
                if (newRefreshToken) {
                    uni.setStorageSync('refreshToken', newRefreshToken);
                    console.log('âœ… æ–°RefreshTokenå·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
                }
                
                console.log('========== Tokenåˆ·æ–°æˆåŠŸ ==========');
                resolve(newToken);
            } else {
                console.error('âŒ å“åº”æ•°æ®ä¸­æ²¡æœ‰accessTokenå­—æ®µ');
                reject(new Error('åˆ·æ–°tokenè¿”å›æ•°æ®æ ¼å¼é”™è¯¯ï¼šç¼ºå°‘accessToken'));
            }
        } catch (error: any) {
            console.error('âŒ Tokenåˆ·æ–°å¼‚å¸¸:', error);
            console.error('å¼‚å¸¸è¯¦æƒ…:', error?.message || error);
            reject(error);
        } finally {
            isRefreshingToken = false;
            refreshTokenPromise = null;
            console.log('========== Tokenåˆ·æ–°æµç¨‹ç»“æŸ ==========');
        }
    });
    
    return refreshTokenPromise;
}

/**
 * HTTPè¯·æ±‚
 * @param options è¯·æ±‚é…ç½®
 */
export function request<T>(options: RequestOptions): Promise<T> {
    // åˆ¤æ–­æ¥å£ç±»å‹
    const isSealAuthApi = options.url.includes('/api/v1/seal/auth/');
    const isSealBusinessApi = options.url.includes('/api/v1/seal/') && !isSealAuthApi;
    
    // ğŸ†• å…³é”®ä¿®å¤ï¼šå¦‚æœæ˜¯sealä¸šåŠ¡æ¥å£ä¸”ç¼ºå°‘sealTokenï¼Œå…ˆè‡ªåŠ¨è·å–
    if (isSealBusinessApi && options.isAuth !== false) {
        const existingSealToken = uni.getStorageSync('sealToken');
        if (!existingSealToken) {
            console.log('[API] ğŸ”§ Sealä¸šåŠ¡æ¥å£ç¼ºå°‘tokenï¼Œå…ˆè‡ªåŠ¨è·å–...');
            return ensureSealTokenInternal().then((token) => {
                console.log('[API] âœ… Seal-Token è·å–å®Œæˆï¼Œtoken å‰20ä½:', token.substring(0, 20) + '...');
                // ğŸ”§ å…³é”®ï¼šç¡®ä¿ token å·²å†™å…¥ storage åå†æ‰§è¡Œè¯·æ±‚
                // ç”±äº ensureSealTokenInternal å†…éƒ¨å·²ç» setStorageSyncï¼Œè¿™é‡Œå†æ¬¡ç¡®è®¤
                const verifyToken = uni.getStorageSync('sealToken');
                console.log('[API] ğŸ” éªŒè¯ storage ä¸­çš„ token:', verifyToken ? (verifyToken.substring(0, 20) + '...') : 'undefined');
                return executeRequest<T>(options, isSealAuthApi, isSealBusinessApi);
            }).catch((error) => {
                console.error('[API] âŒ Seal-Token è·å–å¤±è´¥:', error);
                throw error;
            });
        }
    }
    
    return executeRequest<T>(options, isSealAuthApi, isSealBusinessApi);
}

/**
 * æ‰§è¡Œå®é™…çš„HTTPè¯·æ±‚
 */
function executeRequest<T>(options: RequestOptions, isSealAuthApi: boolean, isSealBusinessApi: boolean): Promise<T> {
    return new Promise<T>((resolve, reject) => {
        // ğŸ”§ å…³é”®ä¿®å¤ï¼šæ ¹æ®åç«¯æ¶æ„é€‰æ‹©æ­£ç¡®çš„è®¤è¯æ–¹å¼
        // 
        // åç«¯æ¶æ„è®¾è®¡ï¼š
        // - /portal/api/v1/seal/** - ä½¿ç”¨ Authorization Token (member token)
        // - /app-api/api/v1/seal/** - è¢« SealAuthInterceptor æ‹¦æˆªï¼Œéœ€è¦ Seal-Token å¤´
        // 
        // ç§»åŠ¨ç«¯ä½¿ç”¨ /app-api å‰ç¼€ï¼Œæ‰€ä»¥ï¼š
        // - seal è®¤è¯æ¥å£ï¼ˆ/auth/*ï¼‰ä½¿ç”¨ Authorization å¤´ï¼ˆç”¨äºå…‘æ¢ tokenï¼‰
        // - seal ä¸šåŠ¡æ¥å£ä½¿ç”¨ Seal-Token å¤´
        // - member æ¥å£ä½¿ç”¨ Authorization å¤´
        
        const token = uni.getStorageSync('token');
        const sealToken = uni.getStorageSync('sealToken');
        
        console.log(`è¯·æ±‚URL: ${options.url}, æ–¹æ³•: ${options.method || 'GET'}, æ¥å£ç±»å‹: ${isSealAuthApi ? 'Sealè®¤è¯' : isSealBusinessApi ? 'Sealä¸šåŠ¡' : 'Member'}`);
        
        // æ„å»ºå®Œæ•´URL - å¤„ç†GETè¯·æ±‚çš„paramså‚æ•°
        let fullUrl = buildFullUrl(options.url);
        
        // å¦‚æœæ˜¯GETè¯·æ±‚ä¸”æœ‰paramså‚æ•°ï¼Œå°†paramsè½¬æ¢ä¸ºæŸ¥è¯¢å­—ç¬¦ä¸²
        if ((options.method === 'GET' || !options.method) && options.params) {
            const queryString = Object.keys(options.params)
                .filter(key => options.params[key] !== undefined && options.params[key] !== null)
                .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options.params[key])}`)
                .join('&');
            
            if (queryString) {
                fullUrl = fullUrl + (fullUrl.includes('?') ? '&' : '?') + queryString;
            }
        }
        
        const headers: any = {
            'Content-Type': 'application/json',
            'tenant-id': TENANT_ID, // ä½¿ç”¨é…ç½®ä¸­çš„ç§Ÿæˆ·ID
            ...options.header
        };
        
        // æ·»åŠ è®¤è¯å¤´
        if (options.isAuth !== false) {
            // Sealä¸šåŠ¡æ¥å£ï¼ˆéè®¤è¯æ¥å£ï¼‰ä½¿ç”¨ Seal-Token
            if (isSealBusinessApi) {
                if (sealToken) {
                    headers['Seal-Token'] = sealToken;
                    console.log('å·²æ·»åŠ Seal-Tokenå¤´:', sealToken.substring(0, 20) + '...');
                } else {
                    console.warn('âš ï¸ Sealä¸šåŠ¡æ¥å£ç¼ºå°‘Seal-Tokenï¼Œè¯·æ±‚å¯èƒ½å¤±è´¥');
                }
            } 
            // Sealè®¤è¯æ¥å£ä½¿ç”¨ Authorizationï¼ˆmember tokenï¼‰
            else if (isSealAuthApi) {
                if (token) {
                    headers['Authorization'] = `Bearer ${token}`;
                    console.log('å·²æ·»åŠ Authorizationå¤´ï¼ˆSealè®¤è¯æ¥å£ï¼‰');
                } else {
                    console.warn('âš ï¸ Sealè®¤è¯æ¥å£ç¼ºå°‘member token');
                }
            }
            // å…¶ä»–æ¥å£ï¼ˆmemberæ¥å£ï¼‰ä½¿ç”¨ Authorization
            else {
                if (token) {
                    headers['Authorization'] = `Bearer ${token}`;
                    console.log('å·²æ·»åŠ Authorizationå¤´ï¼ˆMemberæ¥å£ï¼‰');
                } else {
                    console.warn('âš ï¸ Memberæ¥å£ç¼ºå°‘token');
                }
            }
        }
        
        // è¯¦ç»†æ‰“å°è¯·æ±‚ä¿¡æ¯ï¼Œä¾¿äºè°ƒè¯•
        console.log(`==== APIè¯·æ±‚è¯¦æƒ… ====`);
        console.log(`URL: ${fullUrl}`);
        console.log(`æ–¹æ³•: ${options.method || 'GET'}`);
        console.log(`æ•°æ®: ${JSON.stringify(options.data)}`);
        console.log(`æŸ¥è¯¢å‚æ•°: ${JSON.stringify(options.params)}`);
        console.log(`è¯·æ±‚å¤´: ${JSON.stringify(headers)}`);
        
        if (options.isAuth !== false) {
            if (isSealBusinessApi) {
                console.log(`è®¤è¯çŠ¶æ€: ${sealToken ? 'å·²è®¾ç½®Seal-Token' : 'æœªè®¾ç½®Seal-Token'}`);
            } else {
                console.log(`è®¤è¯çŠ¶æ€: ${token ? 'å·²è®¾ç½®token' : 'æœªè®¾ç½®token'}`);
            }
        } else {
            console.log('è®¤è¯çŠ¶æ€: ä¸éœ€è¦è®¤è¯');
        }
        console.log(`==== APIè¯·æ±‚è¯¦æƒ…ç»“æŸ ====`);
        
        uni.request({
            url: fullUrl,
            method: options.method || 'GET',
            data: options.data,
            header: headers,
            timeout: options.timeout || TIMEOUT,
            success: (res: any) => {
                try {
                    // è¯·æ±‚æˆåŠŸ
                    console.log(`APIå“åº”çŠ¶æ€ç (${options.url}):`, res.statusCode);
                    
                    // æ‰“å°åŸå§‹å“åº”æ•°æ®
                    if (typeof res.data === 'string') {
                        // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œæ‰“å°å‰100ä¸ªå­—ç¬¦ä»¥ä¾¿è°ƒè¯•
                        console.log(`APIåŸå§‹å“åº”(${options.url}, å­—ç¬¦ä¸²):`, res.data.length > 100 ? res.data.substring(0, 100) + '...' : res.data);
                    } else if (typeof res.data === 'object') {
                        console.log(`APIåŸå§‹å“åº”(${options.url}, å¯¹è±¡):`, JSON.stringify(res.data).substring(0, 100) + '...');
                    } else {
                        console.log(`APIåŸå§‹å“åº”(${options.url}, ${typeof res.data}):`, res.data);
                    }
                    
                    let responseData: ApiResponse<T> | null = null;
                    
                    // å¦‚æœè¿”å›çš„æ•°æ®æ˜¯å­—ç¬¦ä¸²ï¼Œå°è¯•è§£æä¸ºJSON
                    if (typeof res.data === 'string') {
                        try {
                            // æ£€æŸ¥æ˜¯å¦ä¸ºç©ºå­—ç¬¦ä¸²æˆ–åªæœ‰ç©ºç™½å­—ç¬¦
                            if (!res.data.trim()) {
                                console.log('å“åº”ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œåˆ›å»ºé»˜è®¤æˆåŠŸå“åº”');
                                responseData = {
                                    code: 200,
                                    msg: 'è¯·æ±‚æˆåŠŸï¼ˆå“åº”ä¸ºç©ºï¼‰',
                                    data: null as any
                                };
                            } else {
                                // âœ… æ£€æµ‹å“åº”æ˜¯å¦ä¸ºHTMLï¼ˆæœåŠ¡ä¸å¯ç”¨ã€è·¯å¾„é”™è¯¯ç­‰æƒ…å†µï¼‰
                                const trimmedData = res.data.trim();
                                if (trimmedData.startsWith('<!DOCTYPE') || 
                                    trimmedData.startsWith('<html') || 
                                    trimmedData.startsWith('<HTML')) {
                                    console.error('âŒ APIè¿”å›äº†HTMLé¡µé¢ï¼Œè€Œä¸æ˜¯JSONæ•°æ®');
                                    console.error('è¯·æ±‚URL:', fullUrl);
                                    console.error('HTTPçŠ¶æ€ç :', res.statusCode);
                                    
                                    // ç»™å‡ºå‹å¥½çš„é”™è¯¯æç¤º
                                    let errorMessage = 'æœåŠ¡å¼‚å¸¸';
                                    if (res.statusCode === 404) {
                                        errorMessage = 'APIæ¥å£ä¸å­˜åœ¨';
                                    } else if (res.statusCode === 401 || res.statusCode === 403) {
                                        errorMessage = 'è®¤è¯å¤±è´¥ï¼Œè¯·é‡æ–°ç™»å½•';
                                    } else if (res.statusCode >= 500) {
                                        errorMessage = 'æœåŠ¡å™¨é”™è¯¯';
                                    } else {
                                        errorMessage = 'APIè·¯å¾„é…ç½®é”™è¯¯';
                                    }
                                    
                                    reject(new Error(errorMessage));
                                    return;
                                }
                                
                                const parsedData = JSON.parse(res.data);
                                responseData = parsedData as ApiResponse<T>;
                                console.log(`APIè§£æåå“åº”(${options.url}):`, JSON.stringify(responseData).substring(0, 100) + '...');
                            }
                        } catch (parseError) {
                            console.error('JSONè§£æå¤±è´¥:', parseError);
                            console.error('JSONè§£æå¤±è´¥çš„åŸå§‹æ•°æ®:', typeof res.data === 'string' ? res.data.substring(0, 200) : res.data);
                            
                            // æ— æ³•è§£æJSONï¼Œç»™å‡ºå‹å¥½æç¤º
                            console.error('âŒ å“åº”æ•°æ®ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
                            
                            let errorMessage = 'æœåŠ¡å¼‚å¸¸';
                            if (res.statusCode === 404) {
                                errorMessage = 'APIæ¥å£ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥æ¥å£è·¯å¾„';
                            } else if (res.statusCode === 401) {
                                errorMessage = 'æœªæˆæƒï¼Œè¯·é‡æ–°ç™»å½•';
                            } else if (res.statusCode === 403) {
                                errorMessage = 'æ— æƒé™è®¿é—®æ­¤èµ„æº';
                            } else if (res.statusCode >= 500) {
                                errorMessage = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
                            } else {
                                errorMessage = 'APIè¿”å›æ ¼å¼é”™è¯¯';
                            }
                            
                            // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„æç¤º
                            uni.showToast({
                                title: errorMessage,
                                icon: 'none',
                                duration: 2500
                            });
                            
                            reject(new Error(errorMessage));
                            return;
                        }
                    } else {
                        // å·²ç»æ˜¯å¯¹è±¡ï¼Œç›´æ¥ä½¿ç”¨
                        responseData = res.data as ApiResponse<T>;
                    }
                    
                    // âœ… ç¡®ä¿ responseData å·²è¢«èµ‹å€¼
                    if (!responseData) {
                        console.error('âŒ responseData æœªåˆå§‹åŒ–');
                        reject(new Error('å“åº”æ•°æ®è§£æå¤±è´¥'));
                        return;
                    }
                    
                    // âœ… ç±»å‹æ–­è¨€ï¼šæ­¤æ—¶ responseData è‚¯å®šä¸ä¸º null
                    const apiResponse: ApiResponse<T> = responseData;
                    
                    // æ ¹æ®ä¸šåŠ¡çŠ¶æ€ç å¤„ç†
                    if (apiResponse.code === 0 || apiResponse.code === 200) {
                        // æˆåŠŸçŠ¶æ€ç 
                        resolve(apiResponse.data);
					} else if (apiResponse.code === 401 || apiResponse.code === 1012005005 || apiResponse.code === 1012005006) {
						// æœªæˆæƒæˆ–Tokenæ— æ•ˆ/è¿‡æœŸé”™è¯¯
						// 401: HTTPæœªæˆæƒ
						// 1012005005: æ— æ•ˆçš„è®¿é—®ä»¤ç‰Œ
						// 1012005006: è®¿é—®ä»¤ç‰Œå·²è¿‡æœŸ
						console.error('========== Tokenæ— æ•ˆ/è¿‡æœŸé”™è¯¯ ==========');
						console.error('é”™è¯¯ç :', apiResponse.code);
						console.error('é”™è¯¯ä¿¡æ¯:', apiResponse.msg);
						console.error('è¯·æ±‚URL:', options.url);
						console.error('å½“å‰token:', uni.getStorageSync('token') ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
						console.error('å½“å‰sealToken:', uni.getStorageSync('sealToken') ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
						console.error('å½“å‰refreshToken:', uni.getStorageSync('refreshToken') ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
						console.error('========================================');
						
						// ğŸ”§ å…³é”®ä¿®å¤ï¼šåŒºåˆ† Seal ä¸šåŠ¡æ¥å£å’Œ Member æ¥å£çš„ 401 é”™è¯¯å¤„ç†
						const isSealBusinessApi = options.url.includes('/api/v1/seal/') && !options.url.includes('/api/v1/seal/auth/');
						const retryCount = options.retryCount || 0;
						
						// å¦‚æœä¸æ˜¯ç™»å½•/åˆ·æ–°tokenæ¥å£ä¸”éœ€è¦è®¤è¯
						if (options.isAuth !== false && 
						    !options.url.includes('/auth/login') && 
						    !options.url.includes('/auth/refresh-token')) {
							
							// ğŸ†• Seal ä¸šåŠ¡æ¥å£è¿”å› 401ï¼šå°è¯•é‡æ–°å…‘æ¢ Seal-Token
							if (isSealBusinessApi && retryCount === 0) {
								console.log('ã€Seal Tokenã€‘Sealä¸šåŠ¡æ¥å£è¿”å›401ï¼Œå°è¯•é‡æ–°å…‘æ¢Seal-Token...');
								
								// ä½¿ç”¨é˜²é‡å¤å…‘æ¢çš„æœºåˆ¶
								const refreshSealToken = async (): Promise<string> => {
									if (isGeneratingSealToken && generateSealTokenPromise) {
										console.log('ã€Seal Tokenã€‘ç­‰å¾…ç°æœ‰å…‘æ¢å®Œæˆ...');
										return generateSealTokenPromise;
									}
									
									isGeneratingSealToken = true;
									generateSealTokenPromise = new Promise<string>(async (resolveToken, rejectToken) => {
										try {
											const { generateSealToken } = await import('./seals/index');
											const newToken = await generateSealToken();
											uni.setStorageSync('sealToken', newToken);
											console.log('ã€Seal Tokenã€‘âœ… Seal-Token é‡æ–°å…‘æ¢æˆåŠŸ');
											resolveToken(newToken);
										} catch (error) {
											console.error('ã€Seal Tokenã€‘âŒ Seal-Token é‡æ–°å…‘æ¢å¤±è´¥:', error);
											rejectToken(error);
										} finally {
											isGeneratingSealToken = false;
											generateSealTokenPromise = null;
										}
									});
									return generateSealTokenPromise;
								};
								
								refreshSealToken()
									.then((newSealToken: string) => {
										console.log('ã€Seal Tokenã€‘å‡†å¤‡é‡è¯•åŸè¯·æ±‚:', options.url);
										// é‡è¯•åŸè¯·æ±‚ï¼Œæ ‡è®°å·²é‡è¯•
										request<T>({
											...options,
											retryCount: 1
										})
											.then(resolve)
											.catch(reject);
									})
									.catch((error: any) => {
										console.error('ã€Seal Tokenã€‘âŒ Seal-Token é‡æ–°å…‘æ¢å¤±è´¥:', error);
										// Seal-Token å…‘æ¢å¤±è´¥ï¼Œä¸è§¦å‘é€€å‡ºç™»å½•ï¼Œåªè¿”å›é”™è¯¯
										// å› ä¸º member token å¯èƒ½ä»ç„¶æœ‰æ•ˆ
										reject(new Error(apiResponse.msg || 'Seal-Tokenè·å–å¤±è´¥'));
									});
								return; // é‡è¦ï¼šæå‰è¿”å›ï¼Œé¿å…æ‰§è¡Œåç»­é€»è¾‘
							}
							
							// Member æ¥å£è¿”å› 401ï¼šå°è¯•åˆ·æ–° member token
							const refreshTokenStr = uni.getStorageSync('refreshToken');
							console.log('å°è¯•tokenåˆ·æ–°æµç¨‹ - refreshTokenå­˜åœ¨:', !!refreshTokenStr, 'é‡è¯•æ¬¡æ•°:', retryCount);
							
							// å¦‚æœæœ‰refreshTokenä¸”æœªé‡è¯•è¿‡ï¼Œå°è¯•åˆ·æ–°tokenåé‡è¯•
							if (refreshTokenStr && retryCount === 0) {
								console.log('ã€Tokenåˆ·æ–°ã€‘å¼€å§‹åˆ·æ–°tokenæµç¨‹...');
								console.log('ã€Tokenåˆ·æ–°ã€‘å½“å‰refreshToken:', refreshTokenStr.substring(0, 20) + '...');
								
								refreshToken()
									.then((newToken) => {
										console.log('ã€Tokenåˆ·æ–°ã€‘âœ… Tokenåˆ·æ–°æˆåŠŸ');
										console.log('ã€Tokenåˆ·æ–°ã€‘æ–°Token:', newToken.substring(0, 20) + '...');
										console.log('ã€Tokenåˆ·æ–°ã€‘å‡†å¤‡é‡è¯•åŸè¯·æ±‚:', options.url);
										// é‡è¯•åŸè¯·æ±‚ï¼Œæ ‡è®°å·²é‡è¯•
										request<T>({
											...options,
											retryCount: 1
										})
											.then(resolve)
											.catch(reject);
									})
									.catch((error) => {
										console.error('ã€Tokenåˆ·æ–°ã€‘âŒ Tokenåˆ·æ–°å¤±è´¥:', error);
										console.error('ã€Tokenåˆ·æ–°ã€‘é”™è¯¯è¯¦æƒ…:', error.message);
										// åˆ·æ–°å¤±è´¥ï¼Œæ¸…é™¤ç™»å½•ä¿¡æ¯å¹¶è·³è½¬
										// ä¼˜åŒ–ç”¨æˆ·æç¤ºä¿¡æ¯ï¼Œé¿å…æ˜¾ç¤ºæŠ€æœ¯æ€§é”™è¯¯
										handleLoginExpired('ç™»å½•ä¿¡æ¯å·²å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•');
										reject(new Error(apiResponse.msg || 'æœªæˆæƒ'));
									});
							} else {
								// æ²¡æœ‰refreshTokenæˆ–å·²ç»é‡è¯•è¿‡ï¼Œç›´æ¥å¤„ç†ç™»å½•è¿‡æœŸ
								const reason = !refreshTokenStr ? 'æ²¡æœ‰refreshToken' : 'å·²é‡è¯•è¿‡ä½†å¤±è´¥';
								console.error('ã€Tokenåˆ·æ–°ã€‘è·³è¿‡åˆ·æ–°æµç¨‹ï¼ŒåŸå› :', reason);
								// ä¼˜åŒ–ç”¨æˆ·æç¤ºä¿¡æ¯ï¼Œé¿å…æ˜¾ç¤ºæŠ€æœ¯æ€§é”™è¯¯
								handleLoginExpired('ç™»å½•ä¿¡æ¯å·²å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•');
								reject(new Error(apiResponse.msg || 'æœªæˆæƒ'));
							}
						} else {
							// ç™»å½•/åˆ·æ–°tokenæ¥å£çš„401é”™è¯¯ï¼Œæ˜¾ç¤ºå…·ä½“é”™è¯¯ä¿¡æ¯
							const errorType = options.url.includes('/auth/login') ? 'ç™»å½•å¤±è´¥' : 'åˆ·æ–°Tokenå¤±è´¥';
							console.error(`ã€${errorType}ã€‘ç›´æ¥è¿”å›401é”™è¯¯:`, apiResponse.msg);
							if (!isRedirectingToLogin) {
								uni.showToast({
									title: apiResponse.msg || errorType,
									icon: 'none'
								});
							}
							reject(new Error(apiResponse.msg || 'æœªæˆæƒ'));
						}
						
						// å¤„ç†ç™»å½•è¿‡æœŸçš„å‡½æ•°
						function handleLoginExpired(reason?: string) {
							if (!isRedirectingToLogin) {
								isRedirectingToLogin = true;
								
								console.error('ã€ç™»å½•è¿‡æœŸå¤„ç†ã€‘åŸå› :', reason || 'æœªçŸ¥');
								console.error('ã€ç™»å½•è¿‡æœŸå¤„ç†ã€‘æ¸…é™¤ç™»å½•ä¿¡æ¯å¹¶è·³è½¬ç™»å½•é¡µ');
								
								// æ¸…é™¤æ‰€æœ‰ç™»å½•ä¿¡æ¯
								uni.removeStorageSync('token');
								uni.removeStorageSync('refreshToken');
								uni.removeStorageSync('sealToken');
								uni.removeStorageSync('userId');
								uni.removeStorageSync('userInfo');
								
								// ä¼˜åŒ–ç”¨æˆ·æç¤ºä¿¡æ¯ï¼Œé¿å…æ˜¾ç¤ºæŠ€æœ¯æ€§é”™è¯¯
								// å¦‚æœå·²ç»åŒ…å«"è¯·é‡æ–°ç™»å½•"ï¼Œç›´æ¥ä½¿ç”¨ï¼›å¦åˆ™ä½¿ç”¨å‹å¥½çš„æç¤º
								let message = 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•';
								if (reason && reason.includes('è¯·é‡æ–°ç™»å½•')) {
									message = reason;
								}
								uni.showToast({
									title: message,
									icon: 'none',
									duration: 2000
								});
								
								// å»¶è¿Ÿè·³è½¬åˆ°ç™»å½•é¡µ
								if (redirectTimer) {
									clearTimeout(redirectTimer);
								}
								redirectTimer = setTimeout(() => {
									uni.reLaunch({
										url: '/pages/login/index',
										success: () => {
											setTimeout(() => {
												isRedirectingToLogin = false;
												redirectTimer = null;
											}, 2000);
										},
										fail: () => {
											isRedirectingToLogin = false;
											redirectTimer = null;
										}
									});
								}, 1500);
							} else {
								console.log('å·²åœ¨è·³è½¬ç™»å½•é¡µï¼Œè·³è¿‡é‡å¤æ“ä½œ');
							}
						}
                    } else {
                        // å…¶ä»–ä¸šåŠ¡é”™è¯¯
                        console.error('APIä¸šåŠ¡é”™è¯¯:', apiResponse.code, apiResponse.msg);
                        reject(new Error(apiResponse.msg || 'è¯·æ±‚å¤±è´¥'));
                    }
                } catch (error) {
                    console.error('âŒ å¤„ç†å“åº”æ•°æ®å¤±è´¥:', error);
                    console.error('è¯·æ±‚URL:', fullUrl);
                    console.error('HTTPçŠ¶æ€ç :', res.statusCode);
                    
                    // ç»™å‡ºå‹å¥½çš„é”™è¯¯æç¤º
                    uni.showToast({
                        title: 'æ•°æ®å¤„ç†å¤±è´¥',
                        icon: 'none',
                        duration: 2000
                    });
                    
                    reject(new Error('æ•°æ®å¤„ç†å¤±è´¥'));
                }
            },
            fail: (err: any) => {
                // è¯·æ±‚å¤±è´¥
                console.error('âŒ ç½‘ç»œè¯·æ±‚å¤±è´¥');
                console.error('è¯·æ±‚URL:', fullUrl);
                console.error('é”™è¯¯ä¿¡æ¯:', err);
                
                // ä¼˜åŒ–é”™è¯¯æç¤º
                let errMsg = 'ç½‘ç»œå¼‚å¸¸';
                const errMsgLower = (err.errMsg || '').toLowerCase();
                
                if (errMsgLower.includes('timeout')) {
                    errMsg = 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ';
                } else if (errMsgLower.includes('fail')) {
                    errMsg = 'ç½‘ç»œè¿æ¥å¤±è´¥';
                } else if (err.errMsg) {
                    errMsg = err.errMsg;
                }
                
                uni.showToast({
                    title: errMsg,
                    icon: 'none',
                    duration: 2000
                });
                
                reject(new Error(errMsg));
            }
        });
    });
}

/**
 * æ„å»ºå®Œæ•´URL
 * @param url ç›¸å¯¹æˆ–ç»å¯¹URL
 * @returns å®Œæ•´URL
 */
function buildFullUrl(url: string): string {
    // å¦‚æœå·²ç»æ˜¯å®Œæ•´URLï¼Œç›´æ¥è¿”å›
    if (url.startsWith('http://') || url.startsWith('https://')) {
        return url;
    }
    
    // ç¡®ä¿URLä»¥/å¼€å¤´
    const normalizedUrl = url.startsWith('/') ? url : `/${url}`;
    
    // ç¡®ä¿API_BASE_URLä¸ä»¥/ç»“å°¾
    const baseUrl = API_BASE_URL.endsWith('/') 
        ? API_BASE_URL.substring(0, API_BASE_URL.length - 1) 
        : API_BASE_URL;
    
    return `${baseUrl}${normalizedUrl}`;
}

/**
 * GETè¯·æ±‚
 * @param url è¯·æ±‚åœ°å€
 * @param data è¯·æ±‚å‚æ•°
 * @param options å…¶ä»–é€‰é¡¹
 */
export function get<T>(url: string, data?: any, options?: Partial<RequestOptions>): Promise<T> {
    // ğŸ”§ ä¿®å¤ï¼šGET è¯·æ±‚å‚æ•°åº”è¯¥æ”¾åˆ° params å­—æ®µï¼Œç¡®ä¿åœ¨æ‰€æœ‰å¹³å°ï¼ˆH5/å°ç¨‹åºï¼‰éƒ½èƒ½æ­£ç¡®è½¬æ¢ä¸ºæŸ¥è¯¢å­—ç¬¦ä¸²
    return request<T>({
        url,
        method: 'GET',
        params: data,  // âœ… ä½¿ç”¨ params è€Œä¸æ˜¯ dataï¼Œç¡®ä¿è·¨å¹³å°å…¼å®¹
        ...options
    });
}

/**
 * POSTè¯·æ±‚
 * @param url è¯·æ±‚åœ°å€
 * @param data è¯·æ±‚å‚æ•°
 * @param options å…¶ä»–é€‰é¡¹
 */
export function post<T>(url: string, data?: any, options?: Partial<RequestOptions>): Promise<T> {
    return request<T>({
        url,
        method: 'POST',
        data,
        ...options
    });
}

/**
 * PUTè¯·æ±‚
 * @param url è¯·æ±‚åœ°å€
 * @param data è¯·æ±‚å‚æ•°
 * @param options å…¶ä»–é€‰é¡¹
 */
export function put<T>(url: string, data?: any, options?: Partial<RequestOptions>): Promise<T> {
    return request<T>({
        url,
        method: 'PUT',
        data,
        ...options
    });
}

/**
 * DELETEè¯·æ±‚
 * @param url è¯·æ±‚åœ°å€
 * @param data è¯·æ±‚å‚æ•°
 * @param options å…¶ä»–é€‰é¡¹
 */
export function del<T>(url: string, data?: any, options?: Partial<RequestOptions>): Promise<T> {
    return request<T>({
        url,
        method: 'DELETE',
        data,
        ...options
    });
}

/**
 * æ–‡ä»¶ä¸Šä¼ ï¼ˆåç«¯ä¸Šä¼ æ¨¡å¼ï¼‰
 * @param url ä¸Šä¼ åœ°å€
 * @param filePath æ–‡ä»¶è·¯å¾„
 * @param options å…¶ä»–é€‰é¡¹
 */
export function uploadFile(url: string, filePath: string, options?: {
    name?: string;
    formData?: Record<string, any>;
    header?: Record<string, any>;
    onProgress?: UploadProgressCallback;
}): Promise<any> {
    return new Promise((resolve, reject) => {
        const token = uni.getStorageSync('token');
        
        const header = {
            'tenant-id': TENANT_ID,
            ...options?.header
        };
        
        // å¦‚æœæœ‰tokenï¼Œæ·»åŠ åˆ°è¯·æ±‚å¤´
        if (token) {
            header.Authorization = `Bearer ${token}`;
        }
        
        // æ„å»ºå®Œæ•´URL
        const fullUrl = buildFullUrl(url);
        console.log('ä¸Šä¼ æ–‡ä»¶åˆ°:', fullUrl);
        
        try {
            const uploadTask = uni.uploadFile({
                url: fullUrl,
                filePath,
                name: options?.name || 'file',
                formData: options?.formData as UTSJSONObject | null | undefined,
                header,
                success: (res) => {
                    try {
                        if (typeof res.data === 'string' && res.data) {
                            // ç¡®ä¿è¿”å›çš„æ•°æ®ä¸ä¸ºç©ºå­—ç¬¦ä¸²
                            let data;
                            try {
                                data = JSON.parse(res.data);
                            } catch (jsonError) {
                                console.error('JSONè§£æå¤±è´¥:', jsonError);
                                console.log('åŸå§‹å“åº”:', res.data);
                                // è¿”å›ç®€å•å¯¹è±¡ä½œä¸ºæ›¿ä»£
                                data = {
                                    code: 200,
                                    msg: 'è¯·æ±‚æˆåŠŸï¼ˆå“åº”æ ¼å¼å¼‚å¸¸ï¼‰',
                                    data: res.data
                                };
                            }
                            console.log(`æ–‡ä»¶ä¸Šä¼ å“åº”(${url}):`, JSON.stringify(data));
                            
                            if (data.code === 0 || data.code === 200) {
                                // ä¸Šä¼ æˆåŠŸï¼Œå¦‚æœæœ‰è¿›åº¦å›è°ƒï¼Œè°ƒç”¨ä¸€æ¬¡100%å®Œæˆ
                                if (options?.onProgress) {
                                    options.onProgress(100);
                                }
                                resolve(data.data);
                            } else if (data.code === 401) {
                                // æœªæˆæƒï¼Œé€šå¸¸æ˜¯tokenè¿‡æœŸ
                                console.error('Tokenå·²è¿‡æœŸæˆ–æ— æ•ˆï¼Œé”™è¯¯ç :', data.code, 'é”™è¯¯ä¿¡æ¯:', data.msg);
                                
                                // ä½¿ç”¨é˜²æŠ–æœºåˆ¶ï¼Œé¿å…é‡å¤è·³è½¬
                                if (!isRedirectingToLogin) {
                                    isRedirectingToLogin = true;
                                    
                                    // æ¸…é™¤æ‰€æœ‰ç™»å½•ä¿¡æ¯
                                    uni.removeStorageSync('token');
                                    uni.removeStorageSync('refreshToken');
                                    uni.removeStorageSync('userId');
                                    uni.removeStorageSync('userInfo');
                                    
                                    uni.showToast({
                                        title: 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•',
                                        icon: 'none'
                                    });
                                    
                                    // å»¶è¿Ÿè·³è½¬åˆ°ç™»å½•é¡µ
                                    if (redirectTimer) {
                                        clearTimeout(redirectTimer);
                                    }
                                    redirectTimer = setTimeout(() => {
                                        uni.reLaunch({
                                            url: '/pages/login/index',
                                            success: () => {
                                                setTimeout(() => {
                                                    isRedirectingToLogin = false;
                                                    redirectTimer = null;
                                                }, 2000);
                                            },
                                            fail: () => {
                                                isRedirectingToLogin = false;
                                                redirectTimer = null;
                                            }
                                        });
                                    }, 1500);
                                } else {
                                    console.log('å·²åœ¨è·³è½¬ç™»å½•é¡µï¼Œè·³è¿‡é‡å¤æ“ä½œ');
                                }
                                
                                reject(new Error(data.msg || 'æœªæˆæƒ'));
                            } else {
                                // å…¶ä»–ä¸šåŠ¡é”™è¯¯
                                console.error('APIä¸šåŠ¡é”™è¯¯:', data.code, data.msg);
                                reject(new Error(data.msg || 'è¯·æ±‚å¤±è´¥'));
                            }
                        } else {
                            // å¤„ç†éå­—ç¬¦ä¸²æˆ–ç©ºå­—ç¬¦ä¸²å“åº”
                            console.log('éæ ‡å‡†JSONå“åº”æ ¼å¼:', res.data);
                            // å¦‚æœå“åº”æˆåŠŸä½†æ•°æ®æ ¼å¼ä¸æ˜¯å­—ç¬¦ä¸²ï¼Œä¹Ÿè®¤ä¸ºä¸Šä¼ æˆåŠŸ
                            if (res.statusCode >= 200 && res.statusCode < 300) {
                                if (options?.onProgress) {
                                    options.onProgress(100);
                                }
                                resolve(res.data);
                            } else {
                                reject(new Error('å“åº”æ ¼å¼é”™è¯¯'));
                            }
                        }
                    } catch (error) {
                        console.error('å¤„ç†ä¸Šä¼ ç»“æœå¤±è´¥:', error);
                        // å¦‚æœçŠ¶æ€ç è¡¨æ˜æˆåŠŸï¼Œå°½ç®¡è§£æå‡ºé”™ä¹Ÿè¿”å›æˆåŠŸ
                        if (res.statusCode >= 200 && res.statusCode < 300) {
                            if (options?.onProgress) {
                                options.onProgress(100);
                            }
                            resolve({});
                        } else {
                            reject(new Error('è§£æå“åº”å¤±è´¥'));
                        }
                    }
                },
                fail: (err) => {
                    console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', err);
                    reject(new Error(err.errMsg || 'ç½‘ç»œå¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•'));
                }
            });
            
            // ç›‘å¬ä¸Šä¼ è¿›åº¦
            if (options?.onProgress && uploadTask) {
                try {
                    console.log('å°è¯•æ·»åŠ ä¸Šä¼ è¿›åº¦ç›‘å¬');
                    
                    // é˜²å¾¡æ€§ç¼–ç¨‹: æ£€æŸ¥onProgressUpdateæ–¹æ³•æ˜¯å¦å­˜åœ¨
                    if (typeof uploadTask.onProgressUpdate === 'function') {
                        uploadTask.onProgressUpdate((res) => {
                            try {
                                console.log('ä¸Šä¼ è¿›åº¦æ›´æ–°:', res.progress);
                                options.onProgress!(res.progress);
                            } catch (progressCallbackError) {
                                console.error('æ‰§è¡Œè¿›åº¦å›è°ƒæ—¶å‡ºé”™:', progressCallbackError);
                                // é”™è¯¯ä¸å½±å“ä¸Šä¼ 
                            }
                        });
                    } else {
                        console.warn('å½“å‰ç¯å¢ƒä¸æ”¯æŒä¸Šä¼ è¿›åº¦ç›‘å¬ (onProgressUpdate æ–¹æ³•ä¸å¯ç”¨)');
                        // æä¾›åˆå§‹è¿›åº¦
                        setTimeout(() => {
                            try {
                                options.onProgress!(0);
                            } catch (error) {
                                console.error('æ‰§è¡Œåˆå§‹è¿›åº¦å›è°ƒæ—¶å‡ºé”™:', error);
                            }
                        }, 0);
                    }
                } catch (progressSetupError) {
                    console.error('è®¾ç½®è¿›åº¦ç›‘å¬æ—¶å‡ºé”™:', progressSetupError);
                    // æä¾›åˆå§‹è¿›åº¦ä½œä¸ºå›é€€
                    setTimeout(() => {
                        try {
                            options.onProgress!(0);
                        } catch (error) {
                            console.error('æ‰§è¡Œåˆå§‹è¿›åº¦å›è°ƒæ—¶å‡ºé”™:', error);
                        }
                    }, 0);
                }
            }
        } catch (error) {
            console.error('åˆ›å»ºä¸Šä¼ ä»»åŠ¡å¤±è´¥:', error);
            reject(new Error('åˆ›å»ºä¸Šä¼ ä»»åŠ¡å¤±è´¥'));
        }
    });
}

/**
 * è·å–é¢„ç­¾åä¸Šä¼ URL
 * @param fileName æ–‡ä»¶å
 * @param directory ç›®å½•
 * @param expirationHours è¿‡æœŸæ—¶é—´ï¼ˆå°æ—¶ï¼‰
 */
export function getPresignedUrl(fileName: string, directory?: string, expirationHours?: number): Promise<any> {
    let url = '/infra/file/presigned-url?name=' + encodeURIComponent(fileName);
    if (directory) {
        url += '&directory=' + encodeURIComponent(directory);
    }
    
    // å¦‚æœæŒ‡å®šäº†è¿‡æœŸæ—¶é—´ï¼Œæ·»åŠ åˆ°è¯·æ±‚å‚æ•°
    if (expirationHours !== undefined && expirationHours > 0) {
        url += '&expiration=' + expirationHours;
    }
    
    return request<any>({
        url,
        method: 'GET',
        isAuth: true
    });
}

/**
 * ç›´æ¥ä¸Šä¼ æ–‡ä»¶åˆ°é¢„ç­¾åURL
 * @param uploadUrl é¢„ç­¾åURL
 * @param filePath æ–‡ä»¶è·¯å¾„
 * @param fileType æ–‡ä»¶ç±»å‹
 * @param onProgress è¿›åº¦å›è°ƒ
 */
export function uploadToPresignedUrl(
    uploadUrl: string,
    filePath: string,
    fileType: string,
    onProgress?: UploadProgressCallback
): Promise<any> {
    return new Promise((resolve, reject) => {
        console.log('å¼€å§‹ä¸Šä¼ æ–‡ä»¶åˆ°é¢„ç­¾åURL:', uploadUrl);
        console.log('æ–‡ä»¶è·¯å¾„:', filePath);
        console.log('æ–‡ä»¶ç±»å‹:', fileType);

        try {
            // æ­¥éª¤1: è·å–æ–‡ä»¶å†…å®¹
            // å¯¹äº uni-app-x, chooseImage è¿”å› blob: URL, æˆ‘ä»¬éœ€è¦å…ˆ fetch è¿™ä¸ª URL è·å–å…¶ ArrayBuffer å†…å®¹
            console.log('æ­£åœ¨è·å–æ–‡ä»¶å†…å®¹...');
            uni.request({
                url: filePath, // ç›´æ¥è¯·æ±‚ blob: æˆ– file: URL
                method: 'GET',
                responseType: 'arraybuffer',
                dataType: 'text', // é˜²æ­¢è‡ªåŠ¨JSONè§£æ
                success: (res) => {
                    console.log('æ–‡ä»¶å†…å®¹è·å–æˆåŠŸï¼Œæ•°æ®å¤§å°:', res.data ? (res.data as ArrayBuffer).byteLength : 0);
                    const fileContent = res.data as ArrayBuffer;

                    if (!fileContent || fileContent.byteLength === 0) {
                        reject(new Error('è¯»å–åˆ°çš„æ–‡ä»¶å†…å®¹ä¸ºç©º'));
                        return;
                    }

                    // æ­¥éª¤2: å°†æ–‡ä»¶å†…å®¹ PUT åˆ°é¢„ç­¾å URL
                    const fileName = getFileNameFromPath(filePath);
                    let contentType = fileType;
                    if (!contentType || contentType === 'application/octet-stream') {
                        const inferredType = getFileTypeFromName(fileName);
                        if (inferredType && inferredType !== 'application/octet-stream') {
                            contentType = inferredType;
                        }
                    }

                    console.log('æ­£åœ¨PUTä¸Šä¼ åˆ°OSS...');
                    const requestTask = uni.request({
                        url: uploadUrl,
                        method: 'PUT',
                        data: fileContent,
                        dataType: 'text', // OSSè¿”å›çš„ä¸æ˜¯JSONï¼Œè®¾ç½®ä¸ºtexté¿å…è‡ªåŠ¨JSONè§£æ
                        header: {
                            'Content-Type': contentType
                        },
                        success: (uploadRes) => {
                            console.log('æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼ŒçŠ¶æ€ç :', uploadRes.statusCode);
                            console.log('OSSå“åº”æ•°æ®ç±»å‹:', typeof uploadRes.data);
                            console.log('OSSå“åº”æ•°æ®:', uploadRes.data);
                            
                            if (uploadRes.statusCode >= 200 && uploadRes.statusCode < 300) {
                                const fileUrl = extractFileUrlFromPresignedUrl(uploadUrl);
                                console.log('æå–çš„æ–‡ä»¶URL:', fileUrl);
                                resolve({
                                    url: fileUrl,
                                    fileName: fileName,
                                    fileType: contentType,
                                    statusCode: uploadRes.statusCode
                                });
                            } else {
                                console.error('ä¸Šä¼ å¤±è´¥ï¼ŒçŠ¶æ€ç :', uploadRes.statusCode, 'å“åº”:', uploadRes.data);
                                reject(new Error(`ä¸Šä¼ å¤±è´¥ï¼ŒçŠ¶æ€ç : ${uploadRes.statusCode}`));
                            }
                        },
                        fail: (uploadErr) => {
                            console.error('æ–‡ä»¶ä¸Šä¼ è¯·æ±‚å¤±è´¥:', uploadErr);
                            reject(uploadErr);
                        }
                    });
                    // uni.request for PUT ä¸æ”¯æŒä¸Šä¼ è¿›åº¦æ›´æ–°ï¼Œè¿›åº¦æ¨¡æ‹Ÿåœ¨ uploadFileAdvanced ä¸­å¤„ç†
                },
                fail: (err) => {
                    console.error('è·å–æ–‡ä»¶å†…å®¹å¤±è´¥:', err);
                    reject(new Error(`è¯»å–æ–‡ä»¶å†…å®¹å¤±è´¥: ${err.errMsg || ''}`));
                }
            });
        } catch (error) {
            console.error('åˆ›å»ºä¸Šä¼ è¯·æ±‚å¤±è´¥:', error);
            reject(error);
        }
    });
}

/**
 * ä»é¢„ç­¾åURLä¸­æå–æ–‡ä»¶URL
 */
function extractFileUrlFromPresignedUrl(presignedUrl: string): string {
    try {
        // ç§»é™¤æŸ¥è¯¢å‚æ•°éƒ¨åˆ†
        const urlWithoutQuery = presignedUrl.split('?')[0];
        console.log('ç§»é™¤æŸ¥è¯¢å‚æ•°åçš„URL:', urlWithoutQuery);
        return urlWithoutQuery;
    } catch (error) {
        console.error('æå–æ–‡ä»¶URLå¤±è´¥:', error);
        return presignedUrl; // å¤±è´¥æ—¶è¿”å›åŸå§‹URL
    }
}

/**
 * é€šçŸ¥æœåŠ¡å™¨è®°å½•æ–‡ä»¶
 * @param fileInfo æ–‡ä»¶ä¿¡æ¯
 */
export function createFileRecord(fileInfo: {
    configId: number;
    path: string;
    name: string;
    url: string;
    type?: string;
    size?: number;
}): Promise<any> {
    console.log('å¼€å§‹è®°å½•æ–‡ä»¶ä¿¡æ¯:', JSON.stringify(fileInfo));
    
    return new Promise((resolve, reject) => {
        // ç›´æ¥ä½¿ç”¨åº•å±‚uni.requestä»¥ä¾¿æ›´å¥½åœ°æ§åˆ¶å’Œè®°å½•è¿‡ç¨‹
        const fullUrl = buildFullUrl('/infra/file/create');
        const token = uni.getStorageSync('token');
        
        console.log('è®°å½•æ–‡ä»¶è¯·æ±‚URL:', fullUrl);
        console.log('è®°å½•æ–‡ä»¶è¯·æ±‚æ•°æ®:', JSON.stringify(fileInfo));
        
        const header: any = {
            'Content-Type': 'application/json',
            'tenant-id': TENANT_ID
        };
        
        // å¦‚æœæœ‰tokenï¼Œæ·»åŠ åˆ°è¯·æ±‚å¤´
        if (token) {
            header.Authorization = `Bearer ${token}`;
        }
        
        uni.request({
            url: fullUrl,
            method: 'POST',
            data: fileInfo,
            header: header,
            success: (res) => {
                console.log('è®°å½•æ–‡ä»¶å“åº”çŠ¶æ€ç :', res.statusCode);
                console.log('è®°å½•æ–‡ä»¶å“åº”å¤´:', JSON.stringify(res.header));
                
                // æ‰“å°å®Œæ•´çš„å“åº”å†…å®¹
                if (typeof res.data === 'string') {
                    console.log('è®°å½•æ–‡ä»¶å“åº”å†…å®¹(å­—ç¬¦ä¸²):', res.data);
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸ºç©ºå­—ç¬¦ä¸²
                    if (!res.data.trim()) {
                        console.log('è®°å½•æ–‡ä»¶å“åº”ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œä½†HTTPçŠ¶æ€ç æˆåŠŸï¼Œè§†ä¸ºæˆåŠŸ');
                        if (res.statusCode >= 200 && res.statusCode < 300) {
                            resolve({ success: true, message: 'è®°å½•æ–‡ä»¶æˆåŠŸï¼ˆå“åº”ä¸ºç©ºï¼‰' });
                            return;
                        }
                    }
                    
                    try {
                        // å°è¯•è§£æJSON
                        const jsonData = JSON.parse(res.data);
                        console.log('è®°å½•æ–‡ä»¶å“åº”å†…å®¹(è§£æå):', JSON.stringify(jsonData));
                        
                        if (jsonData && (jsonData.code === 0 || jsonData.code === 200)) {
                            resolve(jsonData.data);
                        } else {
                            reject(new Error(jsonData?.msg || 'è®°å½•æ–‡ä»¶å¤±è´¥'));
                        }
                    } catch (parseError) {
                        console.error('è§£æå“åº”JSONå¤±è´¥:', parseError);
                        console.error('åŸå§‹å“åº”æ•°æ®:', res.data);
                        
                        // å°è¯•ä¿®å¤å¸¸è§çš„JSONæ ¼å¼é—®é¢˜
                        try {
                            // å°è¯•ä¿®å¤ä¸å®Œæ•´çš„JSON
                            const fixedJson = res.data + '}';
                            const jsonData = JSON.parse(fixedJson);
                            console.log('ä¿®å¤JSONæˆåŠŸ:', JSON.stringify(jsonData));
                            
                            if (jsonData && (jsonData.code === 0 || jsonData.code === 200)) {
                                resolve(jsonData.data);
                                return;
                            }
                        } catch (fixError) {
                            console.log('å°è¯•ä¿®å¤JSONå¤±è´¥:', fixError);
                        }
                        
                        // å¦‚æœHTTPçŠ¶æ€ç è¡¨æ˜æˆåŠŸï¼Œå°½ç®¡JSONè§£æå¤±è´¥ä¹Ÿè¿”å›æˆåŠŸ
                        if (res.statusCode >= 200 && res.statusCode < 300) {
                            console.log('HTTPæˆåŠŸä½†JSONè§£æå¤±è´¥ï¼Œè§†ä¸ºæˆåŠŸ');
                            resolve({ success: true, message: 'è®°å½•æ–‡ä»¶æˆåŠŸï¼ˆå“åº”æ ¼å¼å¼‚å¸¸ï¼‰' });
                        } else {
                            reject(new Error('è§£æå“åº”æ•°æ®å¤±è´¥'));
                        }
                    }
                } else if (typeof res.data === 'object') {
                    console.log('è®°å½•æ–‡ä»¶å“åº”å†…å®¹(å¯¹è±¡):', JSON.stringify(res.data));
                    
                    const responseData = res.data as { code?: number; data?: any; msg?: string };
                    if (responseData && (responseData.code === 0 || responseData.code === 200)) {
                        resolve(responseData.data);
                    } else {
                        reject(new Error(responseData?.msg || 'è®°å½•æ–‡ä»¶å¤±è´¥'));
                    }
                } else {
                    console.log('è®°å½•æ–‡ä»¶å“åº”å†…å®¹(å…¶ä»–ç±»å‹):', res.data);
                    
                    // å¦‚æœHTTPçŠ¶æ€ç è¡¨æ˜æˆåŠŸï¼Œå°½ç®¡å“åº”æ ¼å¼å¼‚å¸¸ä¹Ÿè¿”å›æˆåŠŸ
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve({ success: true, message: 'è®°å½•æ–‡ä»¶æˆåŠŸï¼ˆå“åº”æ ¼å¼å¼‚å¸¸ï¼‰' });
                    } else {
                        reject(new Error('å“åº”æ ¼å¼é”™è¯¯'));
                    }
                }
            },
            fail: (err) => {
                console.error('è®°å½•æ–‡ä»¶è¯·æ±‚å¤±è´¥:', err);
                console.error('é”™è¯¯è¯¦æƒ…:', JSON.stringify(err));
                reject(new Error(err.errMsg || 'ç½‘ç»œå¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•'));
            }
        });
    });
}

/**
 * é«˜çº§æ–‡ä»¶ä¸Šä¼ ï¼ˆå‰ç«¯ç›´ä¼ ï¼‰
 * å¤„ç†æ•´ä¸ªç›´ä¼ æµç¨‹ï¼šè·å–é¢„ç­¾åURL -> ä¸Šä¼ åˆ°OSS -> é€šçŸ¥æœåŠ¡å™¨è®°å½•æ–‡ä»¶
 * @param filePath æ–‡ä»¶è·¯å¾„
 * @param options é€‰é¡¹
 */
export function uploadFileAdvanced(filePath: string, options?: {
    fileName?: string;
    directory?: string;
    fileType?: string;
    onProgress?: (percent: number) => void;
    expirationHours?: number; // æ–°å¢è¿‡æœŸæ—¶é—´é€‰é¡¹
}): Promise<string> {
    return new Promise((resolve, reject) => {
        try {
            // è·å–æ–‡ä»¶ä¿¡æ¯
            const originalFileName = options?.fileName || getFileNameFromPath(filePath);
            const fileType = options?.fileType || getFileTypeFromName(originalFileName);
            const directory = options?.directory || 'default';
            
            // è®¾ç½®è¿‡æœŸæ—¶é—´ï¼Œä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„å€¼ï¼Œå¦åˆ™æŒ‰ç›®å½•ä½¿ç”¨é»˜è®¤å€¼
            let expirationHours = options?.expirationHours;
            if (expirationHours === undefined) {
                // æ ¹æ®ç›®å½•é€‰æ‹©é»˜è®¤è¿‡æœŸæ—¶é—´
                if (directory === UPLOAD_CONFIG.DIRECTORIES.VERIFY) {
                    expirationHours = UPLOAD_CONFIG.EXPIRATION.VERIFY;
                } else {
                    expirationHours = UPLOAD_CONFIG.EXPIRATION.DEFAULT;
                }
            }
            
            // ç¡®ä¿æ–‡ä»¶ååŒ…å«æ‰©å±•å
            let fileName = originalFileName;
            if (!fileName.includes('.')) {
                // å¦‚æœæ–‡ä»¶åæ²¡æœ‰æ‰©å±•åï¼Œå°è¯•ä»MIMEç±»å‹æ¨æ–­
                const extension = getMimeTypeExtension(fileType);
                if (extension) {
                    fileName = `${fileName}.${extension}`;
                    console.log(`æ·»åŠ æ‰©å±•å: ${fileName}`);
                }
            }
            
            // è¿›åº¦å›è°ƒ
            const onProgress = options?.onProgress || (() => {});
            
            console.log(`å¼€å§‹ä¸Šä¼ æ–‡ä»¶: ${fileName}, ç±»å‹: ${fileType}, ç›®å½•: ${directory}, è¿‡æœŸæ—¶é—´: ${expirationHours}å°æ—¶, åŸå§‹è·¯å¾„: ${filePath}`);
            
            // æ­¥éª¤1ï¼šè·å–é¢„ç­¾åURL
            onProgress(10); // å¼€å§‹è·å–é¢„ç­¾åURL
            
            // ä½¿ç”¨async/awaitåŒ…è£…çš„æ–¹å¼å¤„ç†Promiseé“¾
            (async () => {
                try {
                    // æ­¥éª¤1: è·å–é¢„ç­¾åURL
                    console.log('æ­£åœ¨è·å–é¢„ç­¾åURL...');
                    const presignedResponse = await getPresignedUrl(fileName, directory, expirationHours);
                    console.log('è·å–é¢„ç­¾åURLåŸå§‹å“åº”:', JSON.stringify(presignedResponse));

                    // ç¡®ä¿é¢„ç­¾åä¿¡æ¯æ ¼å¼æ­£ç¡®
                    if (!presignedResponse || !presignedResponse.uploadUrl) {
                        console.error('é¢„ç­¾åURLå“åº”æ ¼å¼é”™è¯¯:', presignedResponse);
                        throw new Error('è·å–ä¸Šä¼ URLå¤±è´¥ï¼ŒæœåŠ¡å™¨è¿”å›æ ¼å¼é”™è¯¯');
                    }

                    const presignedInfo = presignedResponse;
                    console.log('è§£æåçš„é¢„ç­¾åä¿¡æ¯:', JSON.stringify({
                        uploadUrl: presignedInfo.uploadUrl,
                        url: presignedInfo.url,
                        configId: presignedInfo.configId,
                        path: presignedInfo.path
                    }));
                    onProgress(30); // è·å–é¢„ç­¾åURLæˆåŠŸ
                    
                    // æ­¥éª¤2: ä¸Šä¼ åˆ°OSS
                    console.log('æ­£åœ¨ä¸Šä¼ åˆ°OSS...');
                    await uploadToPresignedUrl(
                        presignedInfo.uploadUrl, 
                        filePath, 
                        fileType,
                        (progress) => {
                            // æ˜ å°„è¿›åº¦åˆ°30%-90%èŒƒå›´
                            const mappedProgress = 30 + Math.floor(progress * 0.6);
                            onProgress(mappedProgress);
                        }
                    );
                    
                    onProgress(90); // ä¸Šä¼ åˆ°OSSæˆåŠŸ
                    console.log('OSSä¸Šä¼ æˆåŠŸ');
                    
                    // æ­¥éª¤3: è·å–æ–‡ä»¶å¤§å°ï¼ˆéå…³é”®æ­¥éª¤ï¼Œå¤±è´¥ä¸å½±å“æµç¨‹ï¼‰
                    let fileSize = 1024 * 1024; // é»˜è®¤1MB
                    try {
                        fileSize = await getFileSize(filePath);
                        console.log('è·å–æ–‡ä»¶å¤§å°æˆåŠŸ:', fileSize);
                    } catch (sizeError) {
                        console.warn('è·å–æ–‡ä»¶å¤§å°å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', sizeError);
                    }
                    
                    // æ­¥éª¤4: é€šçŸ¥æœåŠ¡å™¨è®°å½•æ–‡ä»¶
                    console.log('æ­£åœ¨è®°å½•æ–‡ä»¶...');
                    console.log('è®°å½•çš„æ–‡ä»¶å:', fileName);
                    console.log('è®°å½•çš„æ–‡ä»¶ç±»å‹:', fileType);
                    
                    try {
                        await createFileRecord({
                            configId: presignedInfo.configId,
                            path: presignedInfo.path,
                            name: fileName,  // ä½¿ç”¨åŒ…å«æ‰©å±•åçš„æ–‡ä»¶å
                            url: presignedInfo.url,
                            type: fileType,
                            size: fileSize
                        });
                        
                        onProgress(100); // å…¨éƒ¨å®Œæˆ
                        console.log('æ–‡ä»¶ä¸Šä¼ å’Œè®°å½•å…¨éƒ¨å®Œæˆ');
                        resolve(presignedInfo.url);
                    } catch (recordError) {
                        console.error('è®°å½•æ–‡ä»¶å¤±è´¥ï¼Œä½†OSSä¸Šä¼ å·²æˆåŠŸ:', recordError);
                        
                        // å³ä½¿è®°å½•å¤±è´¥ï¼Œä¹Ÿè¿”å›æ–‡ä»¶URLï¼Œå› ä¸ºæ–‡ä»¶å·²ç»ä¸Šä¼ åˆ°OSS
                        onProgress(100);
                        console.log('æ–‡ä»¶å·²ä¸Šä¼ åˆ°OSSï¼Œä½†è®°å½•å¤±è´¥ï¼Œä»è¿”å›URL');
                        resolve(presignedInfo.url);
                    }
                } catch (error) {
                    console.error('ä¸Šä¼ è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
                    reject(error);
                }
            })();
        } catch (error: any) {
            console.error('æ–‡ä»¶ä¸Šä¼ åˆå§‹åŒ–å¼‚å¸¸:', error);
            reject(new Error('æ–‡ä»¶ä¸Šä¼ åˆå§‹åŒ–å¼‚å¸¸: ' + (error?.message || String(error))));
        }
    });
}

/**
 * ä»æ–‡ä»¶è·¯å¾„ä¸­æå–æ–‡ä»¶å
 */
function getFileNameFromPath(filePath: string): string {
    console.log('æ­£åœ¨ä»è·¯å¾„æå–æ–‡ä»¶å:', filePath);
    
    // å¤„ç†ç©ºè·¯å¾„
    if (!filePath) {
        console.error('æ–‡ä»¶è·¯å¾„ä¸ºç©º');
        return generateRandomFileName();
    }
    
    // å¤„ç†ä¸åŒå¹³å°çš„è·¯å¾„åˆ†éš”ç¬¦
    const normalizedPath = filePath.replace(/\\/g, '/');
    
    // æå–æ–‡ä»¶å - æ”¯æŒå¤šç§æ ¼å¼
    let fileName = '';
    
    // å¤„ç†ç±»ä¼¼ file:///storage/emulated/0/Download/image.jpg çš„è·¯å¾„
    if (normalizedPath.includes('file://')) {
        const parts = normalizedPath.split('/');
        fileName = parts[parts.length - 1];
    } 
    // å¤„ç†ç±»ä¼¼ content://com.android.providers.media.documents/document/image:123 çš„å†…å®¹URI
    else if (normalizedPath.includes('content://')) {
        // å°è¯•ä»è·¯å¾„ä¸­æå–æ–‡ä»¶å
        const match = normalizedPath.match(/([^\/]+)$/);
        if (match && match[1]) {
            fileName = match[1];
            // å¦‚æœæ–‡ä»¶ååŒ…å«å†’å·ï¼ˆå¦‚content URIä¸­å¸¸è§ï¼‰ï¼Œå°è¯•æå–çœŸå®æ–‡ä»¶å
            if (fileName.includes(':')) {
                const parts = fileName.split(':');
                if (parts.length > 1 && parts[0].match(/^(image|video|audio|document)$/)) {
                    // ç”Ÿæˆä¸€ä¸ªå¸¦æœ‰æ­£ç¡®æ‰©å±•åçš„æ–‡ä»¶å
                    const mediaType = parts[0];
                    const extension = getDefaultExtensionForMediaType(mediaType);
                    fileName = `${mediaType}_${parts[1]}${extension ? '.' + extension : ''}`;
                }
            }
        } else {
            fileName = generateRandomFileName();
        }
    }
    // æ ‡å‡†æ–‡ä»¶è·¯å¾„å¤„ç†
    else {
        const parts = normalizedPath.split('/');
        fileName = parts[parts.length - 1];
    }
    
    // ç¡®ä¿æ–‡ä»¶åæœ‰æ•ˆ
    if (!fileName || fileName.trim() === '') {
        fileName = generateRandomFileName();
    }
    
    console.log('æå–çš„æ–‡ä»¶å:', fileName);
    return fileName;
}

/**
 * ç”Ÿæˆéšæœºæ–‡ä»¶å
 */
function generateRandomFileName(): string {
    const timestamp = new Date().getTime();
    const randomPart = Math.floor(Math.random() * 10000);
    const fileName = `file_${timestamp}_${randomPart}`;
    console.log('ç”Ÿæˆéšæœºæ–‡ä»¶å:', fileName);
    return fileName;
}

/**
 * æ ¹æ®åª’ä½“ç±»å‹è·å–é»˜è®¤æ‰©å±•å
 */
function getDefaultExtensionForMediaType(mediaType: string): string {
    switch (mediaType.toLowerCase()) {
        case 'image': return 'jpg';
        case 'video': return 'mp4';
        case 'audio': return 'mp3';
        case 'document': return 'pdf';
        default: return '';
    }
}

/**
 * ä»æ–‡ä»¶åè·å–æ–‡ä»¶ç±»å‹
 */
function getFileTypeFromName(fileName: string): string {
    const extension = fileName.split('.').pop()?.toLowerCase();
    
    // ç®€å•çš„MIMEç±»å‹æ˜ å°„
    const mimeTypes: Record<string, string> = {
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'gif': 'image/gif',
        'pdf': 'application/pdf',
        'doc': 'application/msword',
        'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'xls': 'application/vnd.ms-excel',
        'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'txt': 'text/plain'
    };
    
    return extension && mimeTypes[extension] ? mimeTypes[extension] : 'application/octet-stream';
}

/**
 * è·å–æ–‡ä»¶å¤§å°ï¼ˆå¼‚æ­¥æ–¹å¼ï¼‰
 */
function getFileSize(filePath: string): Promise<number> {
    return new Promise((resolve) => {
        try {
            // ä½¿ç”¨uni.getFileInfoä»£æ›¿getFileSystemManager
            uni.getFileInfo({
                filePath: filePath,
                success: (res) => {
                    console.log('è·å–æ–‡ä»¶ä¿¡æ¯æˆåŠŸ:', JSON.stringify(res));
                    resolve(res.size || 1024); // é»˜è®¤è‡³å°‘æ˜¯1KB
                },
                fail: (err) => {
                    console.error('è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥:', err);
                    // å¦‚æœå¤±è´¥ï¼Œè¿”å›ä¸€ä¸ªé»˜è®¤å¤§å° (1MB)
                    resolve(1024 * 1024);
                }
            });
        } catch (error) {
            console.error('è·å–æ–‡ä»¶å¤§å°å¼‚å¸¸:', error);
            // å¼‚å¸¸æƒ…å†µä¸‹è¿”å›é»˜è®¤å¤§å° (1MB)
            resolve(1024 * 1024);
        }
    });
}

/**
 * åŒæ­¥ç‰ˆæœ¬ï¼Œå®é™…å†…éƒ¨ä½¿ç”¨å¼‚æ­¥ï¼Œä½†ä¸ºäº†å…¼å®¹APIè¿”å›ä¸€ä¸ªé»˜è®¤å€¼
 */
function getFileSizeSync(filePath: string): number {
    // ç”±äºæ— æ³•åŒæ­¥è·å–ï¼Œå…ˆè¿”å›ä¸€ä¸ªåˆç†çš„é»˜è®¤å€¼(1MB)
    // å®é™…å¤§å°ä¼šåœ¨å¼‚æ­¥æ–¹æ³•ä¸­æ›´æ–°
    return 1024 * 1024;
}

/**
 * ä»MIMEç±»å‹æ¨æ–­æ–‡ä»¶æ‰©å±•å
 */
function getMimeTypeExtension(mimeType: string): string | null {
    // MIMEç±»å‹åˆ°æ‰©å±•åçš„æ˜ å°„
    const mimeToExt: Record<string, string> = {
        'image/jpeg': 'jpg',
        'image/png': 'png',
        'image/gif': 'gif',
        'image/webp': 'webp',
        'application/pdf': 'pdf',
        'application/msword': 'doc',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx',
        'application/vnd.ms-excel': 'xls',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'xlsx',
        'text/plain': 'txt',
        'application/json': 'json',
        'application/xml': 'xml',
        'text/html': 'html',
        'text/css': 'css',
        'application/javascript': 'js',
        'application/zip': 'zip'
    };
    
    // å»é™¤å¯èƒ½çš„å‚æ•°éƒ¨åˆ†
    const baseMimeType = mimeType.split(';')[0].trim();
    
    return mimeToExt[baseMimeType] || null;
}

/**
 * ç®€å•æ–‡ä»¶ä¸Šä¼  - æ ¹æ®é…ç½®è‡ªåŠ¨é€‰æ‹©ä¸Šä¼ æ¨¡å¼
 * @param filePath æ–‡ä»¶è·¯å¾„
 * @param directory ç›®å½•
 * @param onProgress è¿›åº¦å›è°ƒ
 * @param expirationHours è¿‡æœŸæ—¶é—´ï¼ˆå°æ—¶ï¼‰
 */
export function simpleUpload(
    filePath: string, 
    directory: string = 'default',
    onProgress?: UploadProgressCallback,
    expirationHours?: number
): Promise<string> {
    return new Promise((resolve, reject) => {
        try {
            console.log(`å¼€å§‹ä¸Šä¼ æ–‡ä»¶ï¼Œä½¿ç”¨æ¨¡å¼: ${UPLOAD_CONFIG.MODE}, ç›®å½•: ${directory}, æ–‡ä»¶è·¯å¾„: ${filePath}`);
            
            // æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æœ‰æ•ˆ
            if (!filePath) {
                const error = new Error('æ–‡ä»¶è·¯å¾„æ— æ•ˆ');
                console.error(error);
                reject(error);
                return;
            }
            
            // è·å–æ–‡ä»¶ä¿¡æ¯
            const originalFileName = getFileNameFromPath(filePath);
            console.log('åŸå§‹æ–‡ä»¶å:', originalFileName);
            
            // è·å–æ–‡ä»¶ç±»å‹
            const fileType = getFileTypeFromName(originalFileName);
            console.log('æ–‡ä»¶ç±»å‹:', fileType);
            
            // ç¡®ä¿æ–‡ä»¶ååŒ…å«æ‰©å±•å
            let fileName = originalFileName;
            if (!fileName.includes('.')) {
                // å¦‚æœæ–‡ä»¶åæ²¡æœ‰æ‰©å±•åï¼Œå°è¯•ä»MIMEç±»å‹æ¨æ–­
                const extension = getMimeTypeExtension(fileType);
                if (extension) {
                    fileName = `${fileName}.${extension}`;
                    console.log('æ·»åŠ æ‰©å±•ååçš„æ–‡ä»¶å:', fileName);
                }
            }
            
            // æ ¹æ®é…ç½®é€‰æ‹©ä¸Šä¼ æ¨¡å¼
            if (UPLOAD_CONFIG.MODE === 'client') {
                console.log('ä½¿ç”¨å‰ç«¯ç›´ä¼ æ¨¡å¼');
                // å‰ç«¯ç›´ä¼ æ¨¡å¼
                uploadFileAdvanced(filePath, {
                    fileName: fileName,
                    directory: directory,
                    fileType: fileType,
                    onProgress: onProgress,
                    expirationHours: expirationHours // ä¼ é€’è¿‡æœŸæ—¶é—´
                }).then(resolve).catch(reject);
            } else {
                console.log('ä½¿ç”¨åç«¯ä¸Šä¼ æ¨¡å¼');
                // åç«¯ä¸Šä¼ æ¨¡å¼
                uploadFile(filePath, directory, {
                    onProgress: onProgress
                }).then(resolve).catch(reject);
            }
        } catch (error) {
            console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
            reject(error);
        }
    });
}

// å¯¼å‡ºé»˜è®¤å¯¹è±¡
export default {
    get,
    post,
    put,
    del,
    request,
    uploadFile,
    getPresignedUrl,
    uploadToPresignedUrl,
    createFileRecord,
    uploadFileAdvanced,
    simpleUpload
}; 