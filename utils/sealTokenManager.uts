/**
 * Seal Token ç¼“å­˜ç®¡ç†å™¨ï¼ˆç§»åŠ¨ç«¯ï¼‰
 * 
 * å‚è€ƒ PC ç«¯ sealTokenManager.ts å®ç°ï¼Œç¡®ä¿ç§»åŠ¨ç«¯å’Œ PC ç«¯è¡Œä¸ºä¸€è‡´
 * 
 * åŠŸèƒ½ï¼š
 * 1. å…¨å±€å…±äº« Token ç¼“å­˜ï¼ˆå†…å­˜ + uni.Storageï¼‰
 * 2. è‡ªåŠ¨æ£€æŸ¥æœ‰æ•ˆæœŸï¼ˆä½¿ç”¨åç«¯è¿”å›çš„è¿‡æœŸæ—¶é—´ï¼‰
 * 3. è¿‡æœŸæå‰åˆ·æ–°ï¼ˆæå‰ 10 åˆ†é’Ÿï¼‰
 * 4. é¿å…é‡å¤è¯·æ±‚ï¼ˆå¹¶å‘æ§åˆ¶ï¼‰
 * 
 * @author å°ååŒå­¦AI
 */

import { post } from '../api/index'
import { getSealTokenConfig, LOG_PREFIX } from '../config/seal.config'

// Token ç¼“å­˜ç»“æ„
interface TokenCache {
  token: string
  expireTime: string      // ISO æ ¼å¼çš„è¿‡æœŸæ—¶é—´
  expireMinutes: number
}

// ç¼“å­˜ key å¸¸é‡
const STORAGE_KEY_TOKEN = 'sealToken'
const STORAGE_KEY_EXPIRE_TIME = 'sealTokenExpireTime'
const STORAGE_KEY_EXPIRE_MINUTES = 'sealTokenExpireMinutes'

// å†…å­˜ç¼“å­˜
let tokenCache: TokenCache | null = null

// å¹¶å‘æ§åˆ¶
let isRefreshing = false
let refreshPromise: Promise<string> | null = null

/**
 * æ£€æŸ¥ Token æ˜¯å¦å³å°†è¿‡æœŸï¼ˆæå‰ 10 åˆ†é’Ÿåˆ·æ–°ï¼‰
 * ä½¿ç”¨åç«¯è¿”å›çš„ expireTime è€Œä¸æ˜¯è§£æ JWT
 */
function isTokenExpiringSoon(expireTime: string): boolean {
  try {
    const expTime = new Date(expireTime).getTime()
    const now = Date.now()
    const tenMinutes = 10 * 60 * 1000 // æå‰ 10 åˆ†é’Ÿåˆ·æ–°

    const isExpiring = expTime - now < tenMinutes
    
    if (isExpiring) {
      console.log(`[SealTokenManager] â° Token å³å°†è¿‡æœŸ - å‰©ä½™æ—¶é—´: ${Math.round((expTime - now) / 1000 / 60)} åˆ†é’Ÿ`)
    }
    
    return isExpiring
  } catch (error) {
    console.error('[SealTokenManager] è§£æè¿‡æœŸæ—¶é—´å¤±è´¥:', error)
    return true // è§£æå¤±è´¥åˆ™è®¤ä¸ºéœ€è¦åˆ·æ–°
  }
}

/**
 * ä»ç¼“å­˜æˆ– Storage è·å– Token
 */
function getCachedToken(): TokenCache | null {
  // ä¼˜å…ˆä½¿ç”¨å†…å­˜ç¼“å­˜
  if (tokenCache) {
    return tokenCache
  }

  // å°è¯•ä» Storage æ¢å¤
  try {
    const token = uni.getStorageSync(STORAGE_KEY_TOKEN)
    const expireTime = uni.getStorageSync(STORAGE_KEY_EXPIRE_TIME)
    const expireMinutes = uni.getStorageSync(STORAGE_KEY_EXPIRE_MINUTES)

    if (token && expireTime && expireMinutes) {
      tokenCache = {
        token,
        expireTime,
        expireMinutes: Number(expireMinutes)
      }
      console.log(`[SealTokenManager] ğŸ“¦ ä» Storage æ¢å¤ Tokenï¼ˆæœ‰æ•ˆæœŸè‡³: ${expireTime}ï¼‰`)
      return tokenCache
    }
  } catch (error) {
    console.error('[SealTokenManager] ä» Storage æ¢å¤ Token å¤±è´¥:', error)
  }

  return null
}

/**
 * ä¿å­˜ Token åˆ°ç¼“å­˜å’Œ Storage
 */
function saveToken(tokenData: TokenCache): void {
  tokenCache = tokenData
  
  try {
    uni.setStorageSync(STORAGE_KEY_TOKEN, tokenData.token)
    uni.setStorageSync(STORAGE_KEY_EXPIRE_TIME, tokenData.expireTime)
    uni.setStorageSync(STORAGE_KEY_EXPIRE_MINUTES, String(tokenData.expireMinutes))
    console.log(`[SealTokenManager] ğŸ’¾ Token å·²ä¿å­˜ï¼ˆæœ‰æ•ˆæœŸè‡³: ${tokenData.expireTime}ï¼‰`)
  } catch (error) {
    console.error('[SealTokenManager] ä¿å­˜ Token åˆ° Storage å¤±è´¥:', error)
  }
}

/**
 * æ¸…é™¤ Token ç¼“å­˜
 */
export function clearSealToken(): void {
  tokenCache = null
  isRefreshing = false
  refreshPromise = null
  
  try {
    uni.removeStorageSync(STORAGE_KEY_TOKEN)
    uni.removeStorageSync(STORAGE_KEY_EXPIRE_TIME)
    uni.removeStorageSync(STORAGE_KEY_EXPIRE_MINUTES)
    console.log('[SealTokenManager] ğŸ—‘ï¸ Token ç¼“å­˜å·²æ¸…é™¤')
  } catch (error) {
    console.error('[SealTokenManager] æ¸…é™¤ Token å¤±è´¥:', error)
  }
}

/**
 * è°ƒç”¨åç«¯æ¥å£è·å–/åˆ·æ–° Token
 */
async function fetchNewToken(): Promise<TokenCache> {
  const config = getSealTokenConfig('mobile')
  
  console.log(`${LOG_PREFIX} ğŸ”„ è°ƒç”¨åç«¯æ¥å£è·å– Token... expireMinutes: ${config.expireMinutes}`)
  
  // è°ƒç”¨å…‘æ¢æ¥å£
  const response = await post<any>('/api/v1/seal/auth/exchange-token', {
    expireMinutes: config.expireMinutes
  })
  
  if (!response || !response.token) {
    throw new Error('Token å“åº”æ ¼å¼é”™è¯¯')
  }

  return {
    token: response.token,
    expireTime: response.expireTime,
    expireMinutes: response.expireMinutes
  }
}

/**
 * åˆ·æ–° Tokenï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰
 */
async function refreshToken(): Promise<string> {
  try {
    const tokenData = await fetchNewToken()
    saveToken(tokenData)
    console.log(`${LOG_PREFIX} âœ… Token è·å–æˆåŠŸï¼ˆæœ‰æ•ˆæœŸè‡³: ${tokenData.expireTime}ï¼‰`)
    return tokenData.token
  } catch (error: any) {
    console.error(`${LOG_PREFIX} âŒ Token è·å–å¤±è´¥:`, error)
    
    // åŒºåˆ†é”™è¯¯ç±»å‹
    const errorMsg = error?.message || error?.toString() || ''
    const isAuthError = errorMsg.includes('401') || 
                       errorMsg.includes('ç™»å½•') || 
                       errorMsg.includes('è¿‡æœŸ') ||
                       errorMsg.includes('æœªç™»å½•')
    
    if (!isAuthError) {
      // éè®¤è¯é”™è¯¯ï¼Œæ¸…é™¤ç¼“å­˜
      clearSealToken()
    } else {
      console.log(`${LOG_PREFIX} âš ï¸ Member Token è¿‡æœŸï¼Œä¿ç•™ç¼“å­˜ï¼Œç­‰å¾…ç”¨æˆ·é‡æ–°ç™»å½•`)
    }
    
    throw error
  }
}

/**
 * è·å– Seal Tokenï¼ˆå¸¦ç¼“å­˜å’Œè‡ªåŠ¨åˆ·æ–°ï¼‰
 * 
 * é€»è¾‘ï¼ˆä¸ PC ç«¯ä¸€è‡´ï¼‰ï¼š
 * 1. æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨ä¸”æœ‰æ•ˆ
 * 2. æœ‰æ•ˆåˆ™ç›´æ¥è¿”å›
 * 3. æ— æ•ˆæˆ–ä¸å­˜åœ¨åˆ™åˆ·æ–°
 * 4. é˜²æ­¢å¹¶å‘åˆ·æ–°
 * 
 * @returns Promise<string> æœ‰æ•ˆçš„ Seal Token
 */
export async function getSealToken(): Promise<string> {
  console.log(`${LOG_PREFIX} ğŸ“¦ è·å– Seal Token...`)

  // 1. æ£€æŸ¥ member token æ˜¯å¦å­˜åœ¨ï¼ˆå‰ææ¡ä»¶ï¼‰
  const memberToken = uni.getStorageSync('token')
  if (!memberToken) {
    console.error(`${LOG_PREFIX} âŒ æ²¡æœ‰ member tokenï¼Œæ— æ³•è·å– Seal Token`)
    throw new Error('è¯·å…ˆç™»å½•')
  }

  // 2. æ£€æŸ¥ç¼“å­˜
  const cached = getCachedToken()
  
  if (cached && cached.expireTime) {
    // 3. æ£€æŸ¥æ˜¯å¦å³å°†è¿‡æœŸï¼ˆä½¿ç”¨è¿‡æœŸæ—¶é—´è€Œéè§£æJWTï¼‰
    if (!isTokenExpiringSoon(cached.expireTime)) {
      console.log(`${LOG_PREFIX} âœ… ä½¿ç”¨ç¼“å­˜çš„ Tokenï¼ˆæœ‰æ•ˆæœŸè‡³: ${cached.expireTime}ï¼‰`)
      return cached.token
    }
    
    console.log(`${LOG_PREFIX} â° Token å³å°†è¿‡æœŸï¼Œéœ€è¦åˆ·æ–°`)
  } else {
    console.log(`${LOG_PREFIX} ğŸ“­ ç¼“å­˜ä¸­æ²¡æœ‰ Tokenï¼Œéœ€è¦è·å–`)
  }

  // 4. åˆ·æ–° Tokenï¼ˆé˜²æ­¢å¹¶å‘ï¼‰
  if (isRefreshing && refreshPromise) {
    console.log(`${LOG_PREFIX} â³ æ­£åœ¨åˆ·æ–°ä¸­ï¼Œç­‰å¾…åˆ·æ–°å®Œæˆ...`)
    return refreshPromise
  }

  isRefreshing = true
  refreshPromise = refreshToken()

  try {
    const newToken = await refreshPromise
    return newToken
  } finally {
    isRefreshing = false
    refreshPromise = null
  }
}

/**
 * å¼ºåˆ¶åˆ·æ–° Tokenï¼ˆå¿½ç•¥ç¼“å­˜ï¼‰
 */
export async function forceRefreshSealToken(): Promise<string> {
  console.log(`${LOG_PREFIX} ğŸ”„ å¼ºåˆ¶åˆ·æ–° Token...`)
  clearSealToken()
  return getSealToken()
}

/**
 * ç¡®ä¿ Seal Token å­˜åœ¨ä¸”æœ‰æ•ˆ
 * 
 * ğŸ†• ç»Ÿä¸€å…¥å£æ–¹æ³•ï¼ˆæ›¿ä»£ä¹‹å‰çš„ ensureSealTokenï¼‰
 * åœ¨é¡µé¢åŠ è½½æ—¶è°ƒç”¨ï¼Œç¡®ä¿åç»­ API è¯·æ±‚èƒ½æ­£å¸¸å·¥ä½œ
 * 
 * @returns Promise<string> æœ‰æ•ˆçš„ Seal Token
 */
export async function ensureSealToken(): Promise<string> {
  return getSealToken()
}

// å¯¼å‡ºç®¡ç†å™¨å¯¹è±¡ï¼ˆå…¼å®¹ PC ç«¯é£æ ¼ï¼‰
export const sealTokenManager = {
  getToken: getSealToken,
  clearToken: clearSealToken,
  forceRefresh: forceRefreshSealToken,
  ensureToken: ensureSealToken
}

export default sealTokenManager
