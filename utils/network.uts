/**
 * ç½‘ç»œæ£€æŸ¥å·¥å…·æ¨¡å—
 * æä¾›ç½‘ç»œçŠ¶æ€æ£€æµ‹ã€H5æœåŠ¡å¯ç”¨æ€§æ£€æµ‹ç­‰åŠŸèƒ½
 */

/**
 * é”™è¯¯ç±»å‹æšä¸¾
 */
export const ErrorType = {
	NETWORK: 'network',    // ç½‘ç»œé”™è¯¯
	TIMEOUT: 'timeout',    // è¶…æ—¶
	SERVER: 'server',      // æœåŠ¡å™¨é”™è¯¯
	UNKNOWN: 'unknown'     // æœªçŸ¥é”™è¯¯
} as const

export type ErrorTypeValue = typeof ErrorType[keyof typeof ErrorType]

/**
 * ç½‘ç»œæ£€æŸ¥ç»“æœ
 */
export type NetworkCheckResult = {
	success: boolean
	errorType?: ErrorTypeValue
	errorMessage?: string
}

/**
 * H5æœåŠ¡æ£€æŸ¥ç»“æœ
 */
export type H5ServiceCheckResult = {
	available: boolean
	errorType?: ErrorTypeValue
	errorMessage?: string
}

/**
 * æ£€æŸ¥ç½‘ç»œçŠ¶æ€
 * @returns Promise<NetworkCheckResult>
 */
export function checkNetworkStatus(): Promise<NetworkCheckResult> {
	return new Promise((resolve) => {
		uni.getNetworkType({
			success: (res) => {
				if (res.networkType === 'none') {
					resolve({
						success: false,
						errorType: ErrorType.NETWORK,
						errorMessage: 'å½“å‰æ— ç½‘ç»œè¿æ¥\nè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•'
					})
				} else {
					resolve({ success: true })
				}
			},
			fail: () => {
				// æ— æ³•è·å–ç½‘ç»œçŠ¶æ€æ—¶ï¼Œå‡è®¾ç½‘ç»œæ­£å¸¸ï¼Œç»§ç»­å°è¯•
				resolve({ success: true })
			}
		})
	})
}

/**
 * æµ‹è¯•H5æœåŠ¡æ˜¯å¦å¯ç”¨
 * @param url H5æœåŠ¡çš„URL
 * @param timeout è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œé»˜è®¤5000ms
 * @returns Promise<H5ServiceCheckResult>
 */
export function testH5ServiceAvailability(
	url: string,
	timeout: number = 5000
): Promise<H5ServiceCheckResult> {
	return new Promise((resolve) => {
		// ğŸ”§ ä¿®å¤ï¼šå°ç¨‹åºç¯å¢ƒä¸æ”¯æŒ new URL()ï¼Œæ”¹ç”¨æ­£åˆ™è¡¨è¾¾å¼éªŒè¯
		// éªŒè¯ URL æ ¼å¼ï¼šå¿…é¡»ä»¥ http:// æˆ– https:// å¼€å¤´ï¼ŒåŒ…å«æœ‰æ•ˆçš„ä¸»æœºå
		const urlPattern = /^https?:\/\/[^\s/$.?#].[^\s]*$/i
		
		if (!url || typeof url !== 'string') {
			console.error('[ç½‘ç»œæ£€æŸ¥] URLä¸ºç©ºæˆ–æ— æ•ˆ')
			resolve({
				available: false,
				errorType: ErrorType.SERVER,
				errorMessage: 'URLä¸ºç©º\nè¯·è”ç³»æŠ€æœ¯æ”¯æŒ'
			})
			return
		}
		
		if (!urlPattern.test(url)) {
			console.error('[ç½‘ç»œæ£€æŸ¥] URLæ ¼å¼æ— æ•ˆ:', url)
			resolve({
				available: false,
				errorType: ErrorType.SERVER,
				errorMessage: 'URLæ ¼å¼æ— æ•ˆ\nè¯·è”ç³»æŠ€æœ¯æ”¯æŒ'
			})
			return
		}
		
		console.log('[ç½‘ç»œæ£€æŸ¥] URLæ ¼å¼éªŒè¯é€šè¿‡:', url)
		
		const fetchFn = (globalThis as any)?.fetch
		if (typeof fetchFn !== 'function') {
			console.log('[ç½‘ç»œæ£€æŸ¥] URLæ ¼å¼éªŒè¯é€šè¿‡:', url)
			resolve({ available: true })
			return
		}
		
		let finished = false
		const finish = (result: H5ServiceCheckResult) => {
			if (finished) return
			finished = true
			resolve(result)
		}
		
		let controller: any = null
		try {
			const AbortCtrl = (globalThis as any)?.AbortController
			if (typeof AbortCtrl === 'function') {
				controller = new AbortCtrl()
			}
		} catch (e) {
			controller = null
		}
		
		const timer = setTimeout(() => {
			try {
				if (controller) controller.abort()
			} catch (e) {}
			finish({
				available: false,
				errorType: ErrorType.TIMEOUT,
				errorMessage: 'è¿æ¥è¶…æ—¶\nè¯·æ£€æŸ¥ç½‘ç»œçŠ¶å†µåé‡è¯•'
			})
		}, timeout)
		
		fetchFn(url, {
			method: 'GET',
			mode: 'no-cors',
			cache: 'no-store',
			...(controller ? { signal: controller.signal } : {})
		}).then(() => {
			clearTimeout(timer)
			console.log('[ç½‘ç»œæ£€æŸ¥] URLæ ¼å¼éªŒè¯é€šè¿‡:', url)
			finish({ available: true })
		}).catch((error: any) => {
			clearTimeout(timer)
			console.error('[ç½‘ç»œæ£€æŸ¥] æœåŠ¡ä¸å¯è¾¾:', error)
			finish({
				available: false,
				errorType: ErrorType.SERVER,
				errorMessage: 'H5æœåŠ¡æš‚æ—¶ä¸å¯ç”¨\nè¯·ç¨åé‡è¯•æˆ–è”ç³»å®¢æœ'
			})
		})
	})
}

/**
 * åˆ†æWebViewé”™è¯¯å¹¶ç¡®å®šé”™è¯¯ç±»å‹
 * @param error WebViewé”™è¯¯å¯¹è±¡
 * @returns ErrorTypeValue
 */
export function analyzeWebViewError(error: any): ErrorTypeValue {
	const errorCode = error?.errCode || 0
	const errorMsg = (error?.errMsg || '').toLowerCase()

	// ç½‘ç»œç›¸å…³é”™è¯¯ç 
	if (errorCode === -1009 || errorCode === -1001 || 
	    errorMsg.includes('network') || errorMsg.includes('è¿æ¥')) {
		return ErrorType.NETWORK
	}

	// è¶…æ—¶é”™è¯¯
	if (errorCode === -1001 || errorMsg.includes('timeout') || 
	    errorMsg.includes('è¶…æ—¶')) {
		return ErrorType.TIMEOUT
	}

	// æœåŠ¡å™¨é”™è¯¯ï¼ˆ5xxï¼‰
	if (errorCode >= 500 && errorCode < 600) {
		return ErrorType.SERVER
	}

	// é»˜è®¤ä¸ºæœªçŸ¥é”™è¯¯
	return ErrorType.UNKNOWN
}

/**
 * æ ¹æ®é”™è¯¯ç±»å‹è·å–å‹å¥½çš„é”™è¯¯æç¤ºä¿¡æ¯
 * @param errorType é”™è¯¯ç±»å‹
 * @returns string é”™è¯¯æç¤ºä¿¡æ¯
 */
export function getErrorMessage(errorType: ErrorTypeValue): string {
	switch (errorType) {
		case ErrorType.NETWORK:
			return 'ç½‘ç»œè¿æ¥å¤±è´¥\nè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®åé‡è¯•'
		case ErrorType.TIMEOUT:
			return 'è¿æ¥è¶…æ—¶\nè¯·æ£€æŸ¥ç½‘ç»œçŠ¶å†µåé‡è¯•'
		case ErrorType.SERVER:
			return 'H5æœåŠ¡æš‚æ—¶ä¸å¯ç”¨\nè¯·ç¨åé‡è¯•æˆ–è”ç³»å®¢æœ'
		default:
			return 'åŠ è½½å¤±è´¥\nè¯·é‡è¯•æˆ–è”ç³»æŠ€æœ¯æ”¯æŒ'
	}
}

/**
 * è®¾ç½®ç½‘ç»œçŠ¶æ€å˜åŒ–ç›‘å¬å™¨
 * @param callback ç½‘ç»œçŠ¶æ€å˜åŒ–æ—¶çš„å›è°ƒå‡½æ•°
 * @returns è¿”å›å–æ¶ˆç›‘å¬çš„å‡½æ•°
 */
export function setupNetworkListener(
	callback: (isConnected: boolean) => void
): () => void {
	const listener = (res: any) => {
		callback(res.isConnected)
	}
	
	uni.onNetworkStatusChange(listener)
	
	// è¿”å›å–æ¶ˆç›‘å¬çš„å‡½æ•°
	return () => {
		uni.offNetworkStatusChange(listener)
	}
}

/**
 * æ‰§è¡Œå®Œæ•´çš„ç½‘ç»œå’ŒæœåŠ¡æ£€æŸ¥æµç¨‹
 * @param h5Url è¦æ£€æŸ¥çš„H5æœåŠ¡URL
 * @returns Promise<NetworkCheckResult>
 */
export async function performFullCheck(
	h5Url: string
): Promise<NetworkCheckResult> {
	// 1. æ£€æŸ¥ç½‘ç»œçŠ¶æ€
	const networkResult = await checkNetworkStatus()
	if (!networkResult.success) {
		return networkResult
	}

	// 2. æ£€æŸ¥H5æœåŠ¡å¯ç”¨æ€§
	const serviceResult = await testH5ServiceAvailability(h5Url)
	if (!serviceResult.available) {
		return {
			success: false,
			errorType: serviceResult.errorType,
			errorMessage: serviceResult.errorMessage
		}
	}

	return { success: true }
}

